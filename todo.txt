Features To Add:
- Camera
    - can be fixed to something
    - can be used to configure the screen
- Vector field for forces
- Mobile vs regular entities
- Attach external forces to states or to entities
    - use case: gravity to attach to a state
    - use case: knockback on an entity
- Better handling of events
- Scene vs Environment???
- mutable and immutable access
- somehow make a class for sidescroller (maybe a subclass of camera? or some sort of state?)
    - also one for where the camera is locked to the player
- transition action ordering/reordering?
- figure/shape/frame class to be used for sprites, shaped, and animation frames
- think of system for keeping docstrings when making transition conditions

- system for scheduled events
    - for example a transition action that starts playing an animation
        - maybe I can just make a function that starts an animation and run it in the transition action

- entity system:
    - entity class
        - visible entity?
        - animated entity?
    - figure class
        - can be a shape
        - can have a picture
    - animation class
        - has multiple figures that it loops through
    - entity state
        - can change everything about an entity
        - similar to scene system?
            - maybe just make scenes for an entity
                - then scenes would have to work for entity and game
                - how would I pass in entity and game data at the same time?
                - maybe make better system for contextual data access
                    - combining data from different contexts (game AKA global, entity, environment, etc)
                    - combining context
                        - within a specific game scene and specific entity scene, attributes can only be accessed based on both
                    - make it more clear what data can be accessed. maybe something to iterate over it to check a specific attribute for debugging reasons

- scene-specific cursors
    - e.g. if you enter the "play" state, it generates the "entities" in the play state, for example
    - just like with fields, transient, static, and global cursors within scene
    - subcursors can be in scene class attribute, or they can be made in datastore class
        - add to class attribute if you want it to be inherited if you make scene derived classes
        - add to a cursor data store if you want it to be attached to the cursor, not the scene
- variable number subcursors for cursor/scene?
- maybe refactor enter, leave, and update so users don't have to super() every implementation?
    - would just have to make a real _enter that does the actions, then an enter used in _enter and implemented by user

- data store system desired features:
    - data fields can be added from a central location, or can be added to a specific class
    - supports polymorphism (a subclass will have data fields of superclass)
    - supports global, static (class attr), and transient (instance attr) data
    - both cursors and scenes have it
    - context object: when used, automatically searches scenes and contexts from most to least specific
    - how to add features to class?
        - make an inner class?
        - decorate inner or outer class or both?
            - decorate both benefits:
                - inner class can be named anything
            - decorate outer only benefits:
                - less verbose
                - maybe it's bad to let the inner class be named anything if that name isn't going to get used 
    - maybe: passes static type checker
    - three ways to use:
        - scene.data.field
        - cursor.data.field
        - context.data.field

Features Added:
- Three types of data:
    - transient scene data (created when entering scene, destroyed when leaving)
    - static scene data (attached to the scene(s), not destroyed when leaving the scene(s) but only accessible when in the scene(s))
    - game data (attached to the game, available to every scene)
- idea for multiple "contexts":
    - for example, if we're looking at a game that is in a "Play" scene and within that an entity is in the "Dying" scene
    - a context obj is passed to all transition actions, conditions, enter, leave, etc for "outer cursor" context info

Misc:
- No need to be too fancy off the get go:
    - e.g.: don't make something a property until it has to be
    - e.g.: don't make something a required abstract method until it has to be

Todo:
- make git repo (DONE)
- rename state to scene (DONE)
- make system for scenes to hand data over to new scenes (DONE)
- improve data store system (DONE)
- finish transition action system (DONE)
    - add transition action decorator to statemachine (DONE)
- add feature to help with transition actions (DONE)
- add feature to register default factory for user data store transient attributes (DONE)
- actions dependent on transition conditions (DONE)
- make dedicated transition condition type to resolve warnings (DONE)
- make dedicated transition action type (NOT NEEDED)
- make transition action and transition condition systems better (DONE)
    - registering a function as a transition action twice (DONE)
    - registering multiple transition actions per condition (DONE)
- refactor to remove statemachine class (DONE)
    - instead of finalizing using statemachine, when a new class is made remove the strings from the previous classes in the init subclass (DONE)
    - can use class attribute in scene base class to keep track of created classes by name (DONE)
    - also have to keep track of classes referred to by name and methods for checking if all the strings have been resolved (DONE)
- make context class and integrate
    - make context class (DONE)
    - rename game to cursor (DONE)
    - integrate context class with scene code (pass that instead of cursor) (DONE)
        - update previous tests (DONE)
    - rework update to update cursors in cursors (DONE)
- allow for non-methods to be registered as transition conditions (IN PROGRESS)
    - Make base class and two different types of context stores
    - make sure an error is thrown if a function is registered as a condition with the same source twice
- refactor transition conditions and actions and make a more general base class for decorating function/methods and associating them with classes (IN PROGRESS)
- allow transition actions and conditions to be defined BEFORE the scene they are associated with
- scene-specific cursors
    - just like with fields, transient, static, and global cursors within scene, integrate with data store system (DONE)
    - add scene class attribute for subcursors
    - test
- add new tests
- testing, lots of testing
- repackage as package
